import 'package:flutter/material.dart';
import 'package:lite_forms/base_form_fields/lite_form_group.dart';
import 'package:lite_forms/controllers/lite_form_controller.dart';
import 'package:lite_forms/utils/string_extensions.dart';
import 'package:lite_forms/utils/value_serializer.dart';
import 'package:lite_forms/utils/value_validator.dart';

typedef OnChanged = Function(Object? value);

mixin FormFieldMixin<T extends StatefulWidget> on State<T> {
  LiteFormGroup? _group;
  LiteFormGroup get group => _group!;

  late final FormGroupField field;
  late final String _fieldName;

  dynamic _initialValue;
  dynamic get initialValue {
    return _initialValue;
  }

  String? hintText;
  TextStyle? _errorStyle;

  String get formName => group.name;

  late InputDecoration decoration;
  bool _isInitialized = false;

  TextEditingController? get textEditingController {
    return field.getOrCreateTextEditingController();
  }

  /// Checks if a field is initially set to not let it
  /// set initially again
  bool setInitialValue({
    required String formName,
    required String fieldName,
    required VoidCallback setter,
  }) {
    if (!liteFormController.isFieldInitiallySet(
      formName: formName,
      fieldName: fieldName,
    )) {
      setter();
      return true;
    }
    return false;
  }

  void tryDeserializeInitialValueIfNecessary<E>({
    required Object? rawInitialValue,
    required LiteFormValueConvertor? initialValueDeserializer,
  }) {
    final storedValue = liteFormController.tryGetValueForField(
      formName: group.name,
      fieldName: _fieldName,
    ) as E?;
    if (E == String) {
      _initialValue = storedValue ??
          initialValueDeserializer?.call(rawInitialValue)?.toString() ??
          initialValue?.toString();
    } else {
      _initialValue = storedValue ??
          initialValueDeserializer?.call(rawInitialValue) as E? ??
          initialValue as E?;
    }
  }

  void initializeFormField<E>({
    required String fieldName,
    required AutovalidateMode? autovalidateMode,
    required LiteFormValueConvertor serializer,
    required LiteFormValueConvertor? initialValueDeserializer,
    required List<LiteFormFieldValidator<Object?>>? validators,
    required String? hintText,
    required InputDecoration? decoration,
    required TextStyle? errorStyle,
  }) {
    _group = LiteFormGroup.of(context)!;
    this.decoration = decoration ??
        liteFormController.config?.inputDecoration ??
        const InputDecoration();
    this.hintText = group.translationBuilder(hintText);
    if (hintText?.isNotEmpty != true) {
      if (liteFormController.config?.useAutogeneratedHints == true) {
        this.hintText = fieldName.splitByCamelCase();
      }
    }
    if (this.hintText?.isNotEmpty == true) {
      this.decoration = this.decoration.copyWith(
            hintText: this.hintText,
          );
    }

    if (!_isInitialized) {
      _isInitialized = true;
      _errorStyle = errorStyle;
      _fieldName = fieldName;
      field = liteFormController.registerFormFieldIfNone<E>(
        fieldName: _fieldName,
        formName: group.name,
        serializer: serializer,
        validators: validators,
        decoration: decoration,
        autovalidateMode: autovalidateMode,
      );
    }
  }

  TextStyle get errorStyle {
    return _errorStyle ??
        liteFormController.config?.inputDecoration?.errorStyle ??
        TextStyle(color: Theme.of(context).colorScheme.error);
  }
}
