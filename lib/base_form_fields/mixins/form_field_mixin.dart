import 'package:flutter/material.dart';
import 'package:lite_forms/base_form_fields/lite_form_group.dart';
import 'package:lite_forms/controllers/lite_form_controller.dart';
import 'package:lite_forms/utils/string_extensions.dart';
import 'package:lite_forms/utils/value_serializer.dart';
import 'package:lite_forms/utils/value_validator.dart';

typedef OnChanged = Function(Object? value);

mixin FormFieldMixin<T extends StatefulWidget> on State<T> {
  LiteFormGroup? _group;
  LiteFormGroup get group => _group!;

  late final FormGroupField field;
  late final String _fieldName;
  String? _label;

  /// needed to check if the field is in a tree
  String get widgetName {
    return (widget as dynamic).name;
  }

  dynamic _initialValue;
  dynamic get initialValue {
    return _initialValue;
  }

  String? hintText;
  TextStyle? _errorStyle;

  String get formName => group.name;

  InputDecoration? _decoration;
  InputDecoration get decoration => _decoration!;
  bool _isInitialized = false;

  TextEditingController? get textEditingController {
    return field.getOrCreateTextEditingController();
  }

  FocusNode? get focusNode {
    return field.getOrCreateFocusNode();
  }

  @override
  void dispose() {
    super.dispose();
  }

  /// Checks if a field is initially set to not let it
  /// set initially again
  bool setInitialValue({
    required String formName,
    required String fieldName,
    required VoidCallback setter,
  }) {
    if (!liteFormController.isFieldInitiallySet(
      formName: formName,
      fieldName: fieldName,
    )) {
      setter();
      return true;
    }
    return false;
  }

  void tryDeserializeInitialValueIfNecessary<E>({
    required Object? rawInitialValue,
    required LiteFormValueSerializer? initialValueDeserializer,
  }) {
    final storedValue = liteFormController.tryGetValueForField(
      formName: group.name,
      fieldName: _fieldName,
    ) as E?;
    if (E == String) {
      _initialValue = storedValue ??
          initialValueDeserializer?.call(rawInitialValue)?.toString() ??
          rawInitialValue?.toString();
    } else {
      _initialValue = storedValue ??
          initialValueDeserializer?.call(rawInitialValue) as E? ??
          rawInitialValue as E?;
    }
  }


  @override
  void activate() {
    // print('ACTIVATE ${(widget as dynamic).name}');
    super.activate();
  }

  void _mount() {
    WidgetsBinding.instance.addPostFrameCallback(
      (timeStamp) {
        field.mount();
      },
    );
  }
  

  @override
  void deactivate() {
    // print('DEACTIVATE ${(widget as dynamic).name}');
    field.unmount();
    super.deactivate();
  }

  void initializeFormField<E>({
    required String fieldName,
    required String? label,
    required AutovalidateMode? autovalidateMode,
    required LiteFormValueSerializer serializer,
    required LiteFormValueSerializer? initialValueDeserializer,
    required List<LiteValidator>? validators,
    required String? hintText,
    required InputDecoration? decoration,
    required TextStyle? errorStyle,
  }) {
    _group = LiteFormGroup.of(context)!;
    _label = label;

    this._decoration =
        decoration ?? formConfig?.inputDecoration ?? const InputDecoration();
    this.hintText = group.translationBuilder(hintText);
    if (hintText?.isNotEmpty != true) {
      if (formConfig?.useAutogeneratedHints == true) {
        this.hintText = fieldName.splitByCamelCase();
      }
    }
    if (this.hintText?.isNotEmpty == true) {
      this._decoration = this._decoration?.copyWith(
            hintText: this.hintText,
          );
    }

    final TextDirection textDirection = Directionality.of(context);
    final EdgeInsets? decorationContentPadding =
        this._decoration!.contentPadding?.resolve(textDirection);

    final EdgeInsets? contentPadding;
    final decorationIsDense = this._decoration!.isDense == true;
    final bool isError = this._decoration!.errorText != null;
    InputBorder? border;
    if (!this._decoration!.enabled) {
      border = isError ? this._decoration!.errorBorder : this._decoration!.disabledBorder;
    } else {
      border = isError ? this._decoration!.errorBorder : this._decoration!.enabledBorder;
    }
    if (this._decoration!.isCollapsed) {
      contentPadding = decorationContentPadding ?? EdgeInsets.zero;
    } else if (border?.isOutline != true) {
      if (this._decoration!.filled ?? false) {
        contentPadding = decorationContentPadding ??
            (decorationIsDense
                ? const EdgeInsets.fromLTRB(12.0, 8.0, 12.0, 8.0)
                : const EdgeInsets.fromLTRB(12.0, 12.0, 12.0, 12.0));
      } else {
        contentPadding = decorationContentPadding ??
            (decorationIsDense
                ? const EdgeInsets.fromLTRB(0.0, 8.0, 0.0, 8.0)
                : const EdgeInsets.fromLTRB(0.0, 12.0, 0.0, 12.0));
      }
    } else {
      contentPadding = decorationContentPadding ??
          (decorationIsDense
              ? const EdgeInsets.fromLTRB(12.0, 20.0, 12.0, 12.0)
              : const EdgeInsets.fromLTRB(12.0, 24.0, 12.0, 16.0));
    }
    this._decoration = this._decoration!.copyWith(
          contentPadding: contentPadding,
        );

    if (!_isInitialized) {
      _isInitialized = true;
      _errorStyle = errorStyle;
      _fieldName = fieldName;
      field = liteFormController.registerFormFieldIfNone<E>(
        fieldName: _fieldName,
        formName: group.name,
        label: _label,
        serializer: serializer,
        validators: validators,
        decoration: decoration,
        autovalidateMode: autovalidateMode,
      );
    }
    _mount();
  }

  TextStyle get errorStyle {
    return _errorStyle ??
        formConfig?.inputDecoration?.errorStyle ??
        TextStyle(color: Theme.of(context).colorScheme.error);
  }
}
